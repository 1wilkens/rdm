// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

use dbus;
use dbus::arg;

pub trait OrgFreedesktopLogin1Manager {
    type Err;
    fn list_seats(&self) -> Result<Vec<(String, dbus::Path<'static>)>, Self::Err>;
    fn power_off(&self, arg0: bool) -> Result<(), Self::Err>;
    fn reboot(&self, arg0: bool) -> Result<(), Self::Err>;
    fn halt(&self, arg0: bool) -> Result<(), Self::Err>;
    fn suspend(&self, arg0: bool) -> Result<(), Self::Err>;
    fn hibernate(&self, arg0: bool) -> Result<(), Self::Err>;
    fn hybrid_sleep(&self, arg0: bool) -> Result<(), Self::Err>;
    fn can_power_off(&self) -> Result<String, Self::Err>;
    fn can_reboot(&self) -> Result<String, Self::Err>;
    fn can_halt(&self) -> Result<String, Self::Err>;
    fn can_suspend(&self) -> Result<String, Self::Err>;
    fn can_hibernate(&self) -> Result<String, Self::Err>;
    fn can_hybrid_sleep(&self) -> Result<String, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target = dbus::Connection>> OrgFreedesktopLogin1Manager
    for dbus::ConnPath<'a, C>
{
    type Err = dbus::Error;

    fn list_seats(&self) -> Result<Vec<(String, dbus::Path<'static>)>, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"ListSeats".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, dbus::Path<'static>)> = i.read()?;
        Ok(arg0)
    }

    fn power_off(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"PowerOff".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn reboot(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"Reboot".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn halt(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"Halt".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn suspend(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"Suspend".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn hibernate(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"Hibernate".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn hybrid_sleep(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"HybridSleep".into(),
            |msg| {
                let mut i = arg::IterAppend::new(msg);
                i.append(arg0);
            },
        )?;
        m.as_result()?;
        Ok(())
    }

    fn can_power_off(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"CanPowerOff".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn can_reboot(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"CanReboot".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn can_halt(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"CanHalt".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn can_suspend(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"CanSuspend".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn can_hibernate(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"CanHibernate".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn can_hybrid_sleep(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(
            &"org.freedesktop.login1.Manager".into(),
            &"CanHybridSleep".into(),
            |_| {},
        )?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopLogin1ManagerSeatNew {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgFreedesktopLogin1ManagerSeatNew {
    const NAME: &'static str = "SeatNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        (&self.arg0 as &arg::RefArg).append(i);
        (&self.arg1 as &arg::RefArg).append(i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopLogin1ManagerSeatRemoved {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgFreedesktopLogin1ManagerSeatRemoved {
    const NAME: &'static str = "SeatRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        (&self.arg0 as &arg::RefArg).append(i);
        (&self.arg1 as &arg::RefArg).append(i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopLogin1ManagerPrepareForShutdown {
    pub arg0: bool,
}

impl dbus::SignalArgs for OrgFreedesktopLogin1ManagerPrepareForShutdown {
    const NAME: &'static str = "PrepareForShutdown";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        (&self.arg0 as &arg::RefArg).append(i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopLogin1ManagerPrepareForSleep {
    pub arg0: bool,
}

impl dbus::SignalArgs for OrgFreedesktopLogin1ManagerPrepareForSleep {
    const NAME: &'static str = "PrepareForSleep";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        (&self.arg0 as &arg::RefArg).append(i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        Ok(())
    }
}
